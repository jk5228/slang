# An LR(1) parser generated by parsegen.py. This file is automatically
# generated. Do not edit.

import pickle, node, action
from collections import defaultdict

# Return a parse table usable in a parser given a table object loaded from a
# parse table dump.
def usable(dump_table):
    table = [defaultdict(lambda: None) for state in dump_table]

    for (i, state) in enumerate(dump_table):
        for (sym, act_tup) in state:
            act = None
            if act_tup[0] == 'SHIFT':
                act = action.SHIFT(*act_tup[1:])
            elif act_tup[0] == 'GOTO':
                act = action.GOTO(*act_tup[1:])
            elif act_tup[0] == 'REDUCE':
                act = action.REDUCE(*act_tup[1:])
            else:
                act = action.ACCEPT()
            table[i][sym] = act

    return table

end_sym = '{0}'
tlist = [{1}]
clist = [{2}]
table = usable(pickle.load(open('{3}', 'rb')))

# Return the abstract syntax tree given a concrete syntax tree. If the root of
# the concrete syntax tree is contracted, then the resulting abstract syntax
# tree will be a list of trees.
def ast(cst):
    if type(cst) == node.nonterminal:       # Nonterminal
        children = []
        for child in cst.children:
            children.extend(ast(child))
        if cst.sym in clist:                # Contract nonterminal
            return children
        else:                               # Keep nonterminal
            cst.children = children
            return [cst]
    elif cst.sym in tlist:                  # Keep terminal
        return [cst]
    else:                                   # Discard terminal
        return []

# Return an abstract syntax tree given a token iterator.
def parser(tokens):
    # LR(1) parsing engine:
    state_stk = [0]
    stack = []
    token = None
    act = None

    while True:

        # print('stack: %s' % str(stack))
        # print('state stack: %s' % str(state_stk))

        # Get next token
        if not token:
            try:
                token = next(tokens)
            except StopIteration:
                token = (end_sym, end_sym)

        # print('token: %s' % str(token))

        # Get next action
        act = table[state_stk[-1]][token[0]]
        # print('action: %s' % act)

        if not act:                         # ERROR

            raise SyntaxError('unexpected token %s' % str(token))

        elif type(act) == action.SHIFT:     # SHIFT

            t = node.terminal(token[0], token[1])
            # print('t.sym: %s' % t.sym)
            # print('t.children: %s' % t.children)
            stack.append(t)
            state_stk.append(act.state_num)
            token = None

        elif type(act) == action.REDUCE:    # REDUCE

            children = stack[len(stack)-act.pop_num:]
            for i in range(act.pop_num):
                stack.pop()
                state_stk.pop()
            t = node.nonterminal(act.nt, children)
            # print('t.sym: %s' % t.sym)
            # print('t.children: %s' % t.children)
            stack.append(t)
            act = table[state_stk[-1]][t.sym]
            # print('action: %s' % act)
            state_stk.append(act.state_num)

        elif type(act) == action.ACCEPT:    # ACCEPT

            return ast(stack[-1])