# An LR(1) parser generated by parsegen.py. This file is automatically
# generated. Do not edit.

import pickle, node, action
from collections import defaultdict

# Return a parse table usable in a parser given a table object loaded from a
# parse table dump.
def usable(dump_table):
    table = [defaultdict(lambda: None) for state in dump_table]

    for (i, state) in enumerate(dump_table):
        for (sym, act_tup) in state:
            act = None
            if act_tup[0] == 'SHIFT':
                act = action.SHIFT(*act_tup[1:])
            elif act_tup[0] == 'GOTO':
                act = action.GOTO(*act_tup[1:])
            elif act_tup[0] == 'REDUCE':
                act = action.REDUCE(*act_tup[1:])
            else:
                act = action.ACCEPT()
            table[i][sym] = act

    return table

end_sym = '{0}'
table = usable(pickle.load(open('{1}', 'rb')))

def parser(tokens):
    # LR(1) parsing engine:
    state_stk = [0]
    stack = []
    token = None
    act = None

    while True:

        # print('stack: %s' % str(stack))
        # print('state stack: %s' % str(state_stk))

        # Get next token
        if not token:
            try:
                token = next(tokens)
            except StopIteration:
                token = (end_sym, end_sym)

        # print('token: %s' % str(token))

        # Get next action
        act = table[state_stk[-1]][token[0]]
        # print('action: %s' % act)

        if not act:                         # ERROR

            raise SyntaxError('unexpected token %s' % str(token))

        elif type(act) == action.SHIFT:     # SHIFT

            t = node.node(token[0], token[1])
            # print('t.nt: %s' % t.nt)
            # print('t.children: %s' % t.children)
            stack.append(t)
            state_stk.append(act.state_num)
            token = None

        elif type(act) == action.REDUCE:    # REDUCE

            children = stack[len(stack)-act.pop_num:]
            for i in range(act.pop_num):
                stack.pop()
                state_stk.pop()
            t = node.node(act.nt, children)
            # print('t.nt: %s' % t.nt)
            # print('t.children: %s' % t.children)
            stack.append(t)
            act = table[state_stk[-1]][t.nt]
            # print('action: %s' % act)
            state_stk.append(act.state_num)

        elif type(act) == action.ACCEPT:    # ACCEPT

            return stack[-1]